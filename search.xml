<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Build RDM from source]]></title>
    <url>%2F2018%2F07%2F31%2Finstall-rdm-on-macos%2F</url>
    <content type="text"><![CDATA[Redis Desktop Manager可以从源码编译用以测试和学习。但如果需要使用，则应该从官网下载使用。（Windows免费，MacOS版本需要订阅）。以下记录了从源码编译rdm的方法。 Get source1$ git clone --recursive https://github.com/uglide/RedisDesktopManager.git -b 0.9 rdm &amp;&amp; cd ./rdm Build on macOS Install Xcode with Xcode build tools. Install Homebrew Copy plist 1$ cd ./src &amp;&amp; cp ./resources/Info.plist.sample ./resources/Info.plist Building RDM dependencies require i.a. openssl and make. Install them: 1$ brew install openssl cmake Build RDM dependencies 1$ ./configure Install qt and qt-creator 12$ brew install qt$ brew cask install qt-creator Copy crashreporter to directory (download) 1$ cp ~/Downloads/crashreporter ./bin/osx/debug/crashreporter Run Qt Creator open project ./rdm/src/rdm.pro open Projects –&gt;Manage Kits Qt Versions: Add – &gt; selected /usr/local/Cellar/qt/5.11.1/bin/qmake Kits : Qt version –&gt; selected Qt 5.11.1(5.11.1) Kits: Compiler –&gt; C &amp; C++ –&gt; Clang(C,x86 64bit in /usr/bin) &amp; Clang(C++, x86 64bit in /usr/bin) update build settings: selected Edit build configuration Release Modify rdm.pro 1#debug: CONFIG-=app_bundle Run，Click Run button Move app to applications 1$ mv ./bin/osx/debug/rdm.app ~/Applications/]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>rdm</tag>
        <tag>macos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用AHK阻止Windows系统自动锁定]]></title>
    <url>%2F2018%2F07%2F25%2Fautohotkey-lockout%2F</url>
    <content type="text"><![CDATA[背景：最近在使用某云桌面，客户端是Windows系统。它有自动锁定机制，而且与Windows操作系统的自动锁定是独立的。也就是说，在Windows系统中设置了禁止锁屏或者关闭显示器、硬盘等是无效的，云桌面仍然会在没有操作后的5分钟之后锁定系统。 经测试发现，云桌面的自动锁定机制是：鼠标和键盘空闲超过5分钟，就会锁定系统（只动鼠标或者只动键盘也是会被判定为闲置，会被锁定）。所以我们需要让鼠标和键盘周期性地动起来，而且尽量不影响正常的操作。 AutoHotKey是一款Windows上的自动化快捷键脚本（Automation, Hotkeys, Scripting）。https://autohotkey.com/docs/AutoHotkey.htm 安装AHK从官网下载安装包，双击进行安装。 编写AHK脚本将下面脚本保存为Iamhere.ahk文件。（该脚本会每分钟自动按下键盘的Scroll Lock键同时移动鼠标一个像素并立即移回原位） 12345678910111213141516171819202122232425262728293031; I'm always online; Press Scroll Lock key and move mouse one pixel per minute.; Quit: Press Ctrl + Alt + Q.counter := new SecondCountercounter.Start()^!q:: counter.Stop()ExitApp; An example class for counting the seconds...class SecondCounter &#123; __New() &#123; this.interval := 60000 this.timer := ObjBindMethod(this, "Tick") &#125; Start() &#123; timer := this.timer SetTimer % timer, % this.interval &#125; Stop() &#123; timer := this.timer SetTimer % timer, Off &#125; Tick() &#123; Send &#123;ScrollLock&#125; Send &#123;ScrollLock&#125; MouseMove, 0, 1, 0, R MouseMove, 0, -1, 0, R &#125;&#125; 可以替换ScrollLock为其他键，鼠标移动是MouseMove, 0, 1, 0, R指的是在相对位置纵向移动一个像素，参数依次是：12340（横向）,1（纵向）,0（速度，值越小速度越快）, R（相对位置，如果绝对位置则不用设置） 生成exe文件使用AutoHotKey将刚才的脚本文件转换为可执行的exe文件，配上图标。 运行现在就可以使用双击使用啦。启动后，会在任务栏出现小图标 。 如果要退出右键任务栏的小图标，点击Exit （快捷键：Ctrl + Alt + Q）。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>autohotkey</tag>
        <tag>windows</tag>
        <tag>ahk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emacs Tutorial (26.1)]]></title>
    <url>%2F2018%2F07%2F23%2Femacs-tutorial%2F</url>
    <content type="text"><![CDATA[这是Emacs的官方教程，在Emacs中可以随时使用C-h t阅读。作为Emacs新人，建议从这篇教程开始学习Emacs。 Emacs 命令组合键有两个： C-&lt;chr&gt;: 按住Control键同时输入其他字符 M-&lt;chr&gt;: 按住Meta或Alt键同时输入其他字符 注意：结束Emacs会话，使用 C-x C-c。 放弃输入一半的命令，使用C-g。 退出帮助手册，使用C-x k \。 概要（summary） C-v向下滚动一个屏幕（底部会有两行重复现实的内容，以便于继续阅读） M-v向上滚动一个屏幕（也可以使用&lt;Esc&gt;-v） C-l清除屏幕并重新显示文本，滚动文本，使光标所在的文本显示在屏幕中间、顶部、底部 基本光标控制（basic cursor control） C-p向上移动一行 C-n向下移动一行 C-b向前移动一个字符 C-f向后移动一个字符 M-b向前移动一个单词 M-f向后移动一个单词 C-a移动到行首 C-e移动到行末 M-a移动到句首 M-e移动到句末 M-&lt;移动到文件开始 M-&gt;移动到文件末尾 注意：多数Emacs命令都有接收一个数字参数，数字将会成为改命令的重复次数。格式为：C-u 数字 命令，或者M-数字 命令。推荐使用C-u的方式，它在任何终端都可以生效。 eg: C-u 8 C-v 如果Emacs停止响应（if Emacs stops responding）如果Emacs停止响应，可以是使用C-g安全地终止。也可以用C-g终止一个执行时间过长的命令。在你输入一个命令后，正要输入数字参数时却不想继续执行命令时，你可以使用C-g来取消命令。例如：输入C-u 100 ，然后输入C-g。这时候输入C-f，只会向后移动一个字符，因为C-g已经取消了C-u 100这条命令。 禁用命令（disabled commands）一些Emacs命令是’disabled’状态，所以新手并不会偶然间执行到它。如果输入一条禁用的命令，Emacs将会显示信息，询问你是否想要继续执行这条命令。如果你真的想要尝试这条命令，输入&lt;SPC&gt;。通常，如果你不想执行被禁用的命令，输入n。例如：输入C-x C-l(这是一个被禁用的命令)，然后输入n。 窗口（windows）Emacs可以有多个”windows”，每个显示自己的内容。后面会说明如何使用多个窗口，现在先了解如何关掉额外的窗口而回到基本的单窗口模式。例如： C-x 1 一个窗口（kill掉其他所有窗口） 移动光标到此行，然后执行C-u 0 C-l 输入C-h k C-f，会有一个新的窗口显示C-f命令的文档，然后本窗口宽度会收窄 输入C-x 1，会看到刚才的文档窗口消失掉了 有一系列的以CONTROL-x开头的命令；他们很多关于窗口、文件、缓存和有关的东西；这些命令是2、3或4个字符的长度。 插入和删除（inserting and deleting）如果要插入文本，直接输入就可以。普通的字符，就像A, 7, *, 等等…输入即可见。而输入换行符，需要输入&lt;Return&gt;（有些键盘中是&lt;Enter&gt;）删除字符之前需要将光标移动到位置，输入&lt;DEL&gt;。这个键在键盘上通常标记为”Backspace”。在你的键盘上也许有另一个键标记为”Delete”，但这并不是我们所说的&lt;DEL&gt;。当输入内容非常多，超过显示的行宽，这些内容将”继续”显示在第二行。如果使用图形化界面，内容边界处会出现一个小的箭头，这样标记出这是一行连续的内容。如果使用文本终端，这个连续的标记是一个反斜杠“\”，出现在屏幕最右侧。可以就像删除普通字符那样去删除一个换行符。删除两行之间的换行符，会使两行内容合并为一行。如果合并后的内容长度太长超过显示宽度，那么会就会显示一个连续符号。&lt;Return&gt;键是特殊的，有时按下它不只是插入一个换行符。这依赖于周围的文本，它也许会在一个换行符之后插入空白字符，以便于在新行中从哪个位置开始输入，与前一行对齐。我们将这种行为称作“electric”。12&gt;&gt; 这是一个&lt;Return&gt;的&quot;electric&quot;例子 在本行的末尾输入&lt;Return&gt;。 你会发现新行是从“在”的位置开始的。 还记得大多数Emacs命令可以被重复多次吧；这也包含文本字符，也就是说可以多次重复插入同一个字符。例如：C-u 8 *，会出现******** 现在，你已经学到了在Emacs中输入和修正错误的方式。你可以删除单词或者行。总结如下： &lt;DEL&gt;删除光标前的一个字符 C-d删除光标后的一个字符 M-&lt;DEL&gt;删除光标前的一个单词 M-d删除光标后的一个单词 C-k删除光标后的字符直到行末 M-k删除光标后的字符直到句末 注意：&lt;DEL&gt;和C-d对M-&lt;DEL&gt;和M-d是从C-f和M-f平行延伸而来。 C-k和M-k类似于C-e和M-e，如果把一行和一句作为类比的话。 你也可以用同一个方法kill掉文本中的其中任何一段。移动光标到这部分的一端，输入C-&lt;SPC&gt;（也就是空格键，这时Emacs会显示”Mark set”）。然后，移动光标到想要删除文本的另一端。Emacs会高亮显示你输入C-&lt;SPC&gt;的位置到光标位置之间的文本。最后，输入C-w。高亮的文本会被立即删除。 “killing”和”deleting”的区别在于”killed”删除后的文本可以被重新插入，而”deleted”删除后的文本不能被重新插入，鉴于”deleted”删除后的东西不能用这种方式重新插入（实际上也可以，回退删除操作–在下面会讲到）。重新插入被killed的文本，这种操作被称为”yanking”。（想象一下那些被带走的文本是被拽回来，或者是拉回来的）一般，移除大量文本的命令使用”kill”删除（它们已经设置好，你可以把文本”拽”回来），而移除一个字符或者仅移除空行、空格的命令使用”delete”删除（所以你不能”拽”回这些文本）。没有参数的&lt;DEL&gt;和C-d命令是”deletion”最简单的例子。当传入参数时，它们会被替换为”kill”操作。 注意：输入一次C-k会删除该行的文本，再次输入才会删除该行，后面的其他文本会向上移动一行。C-k会特殊对待数字参数：会同时删除多行的文本和行标记。这不仅仅是重复。C-u 2 C-k会删除两行和行标记；输入两次C-k却不会这样。 你可以yank文本使它回到删除前的位置，或者是你正在编辑的其他位置，或者是一个不同的文件中。你可以yank多次相同的文本；他会复制出多个副本。一些编辑器把”killing”和”yanking”称为”cutting”和”pasting”。 yanking的命令是C-y。它会在当前光标所在位置重新插入最后被killed删除的文本。 如果在同一行多次C-y，所有被killed删除的文本会被保存在一起，而一次C-y也可以yank多行内容。 如果你想要yank一些内容的时候，却删除了另一些，那么该怎么做？C-y可以yank最近kill删除的内容。但是之前的内容是会丢失的。这时可以使用M-y命令来找回。在使用C-y找回最近一次删除的内容后，输入M-y会将上一次kill的内容yank回来。每输入一次M-y就会yank更早一次kill的内容。当找到正在寻找的内容时，不需要其他操作。只是继续编辑，把需要yank的内容留在原处即可。 输入足够多次的M-y后，将会回到开始的位置。（也就是最近删除的内容） 撤销（undo）如果对内容作出修改后发现有错误，可以使用撤销命令C-/。 通常，一次C-/命令会执行一次撤销更改；如果在一行中多次重复执行C-/，每次执行都会撤销之前的一条命令。 需要注意两点： 不会涉及到没有修改内容的命令（这指的是光标的移动和滚动屏幕等命令） 自插入字符通常会将20个为一组来处理（这是为了减少你C-/的次数） C-_也是一个撤销的命令；它的工作方式与C-/相同。在有些终端，输入C-/实际上是发送C-_命令给Emacs。又或者，C-x u也是与C-/完全相同，但它不太方便输入。 为C-/，C-_或C-x u传入数字型参数来指定命令的重复次数。 可以撤销delete删除的内容，也可以撤销kill删除的内容。对于killing和deleting这两种删除方式只会影响C-y命令，对于撤销来说是没有区别的。 文件（files）为了将输入的内容持久化保存，你必须将它们放在文件中。否则，在你退出Emacs的时候就会消失。为了把内容存放在文件中，必须在输入内容之前”find”一个文件。（也可以被称为”visiting”） 找到一个文件的意思是在Emacs里可以看到这个文件内容。在很多方面，这就像在编辑文件本身。无论如何，你对文件的修改是不会持久化保存，直到使用”save”保存到文件。这是为了当你不想要的时候，避免在系统上留下一个编辑了一半的文件。即使你保存，Emacs会保留一个重命名后的原文件，以便随后你发现那是个错误的修改。 观察屏幕底部会看到有一行以破折号开头的内容，开头是类似于”-:– TUTORIAL”这样的内容。屏幕这部分通常显示的是你访问的文件名。现在，你正在访问的是一个Emacs引导手册的个人副本，被称为”TUTORIAL”。当你使用Emacs找到一个文件，文件名就会显示在那个位置。 找文件的特殊之处是，你必须说出文件名称。我们说”reads an argument”（这个例子中，argument就是文件名）。输入下面的命令C-x C-f找到一个文件 Emacs会要求你输入文件名。输入的文件名会出现在屏幕底部。底部行在被用作输入时，就叫做迷你缓冲区（minibuffer）。可以使用正常的Emacs编辑命令来编辑文件名。 在输入文件名时（或者是任何迷你缓冲区的输入），可以使用C-g随时取消。 文件名输入完成后，使用&lt;Return&gt;来表示结束。迷你缓冲区消失，C-x C-f命令就去查找你选择的文件。 这时候文件内容便会显示在屏幕上，你可以编辑内容。当想要持久化保存修改时，输入命令C-x C-s保存文件 Emacs里的文本会被复制到文件。第一次这样做，Emacs会重命名原文件为一个新的名字，所以它并不会丢失。新文件名是在原文件名的结尾处增加一个”~”。当完成保存，Emacs会显示文件写入的文件名。C-x C-s TUTORIAL &lt;Return&gt;这将会保存这份教程，文件名为”TUTORIAL”，并在底部显示”Wrote …TUTORIAL” 你可以查找一个存在的文件，去浏览和编辑它。也可以找到一个并不存在的文件，这是使用Emacs创建新文件的一种方式：找一个文件，从空白开始，开始插入一些内容到这个文件。当你要求保存文件时，Emacs实际上是新建了这个文件。那之后，就可以看作是编辑一个已存在的文件。 缓存（buffers）如果使用C-x C-f找到第二个文件，那第一个文件会留在Emacs中。你可以使用C-x C-f再次跳转回来。 Emacs存储每个文件内容的内部对象就叫做”buffer”。查找一个文件在Emacs内部创造一个新的缓存区。使用C-x C-b可以看到当前存在的缓存区的清单。C-x C-b缓存区清单 可以看到每个缓冲区的名称等信息。你在Emacs窗口看到的任何内容都是某个缓冲区的一部分。C-x 1关掉缓存区清单的窗口 当有多个缓存区时，只会有一个是”current”，就是你正在编辑的缓存区。如果需要编辑另一个缓存区，就需要切换它。想要切换到对应文件的缓存区，可以使用C-x C-f命令来访问文件。有一个更简便的方式：使用C-x b命令。这个命令需要输入缓存区的名称。 大多数的时候，缓存区的名字与文件名相同（不包括文件目录部分）。然而，这也不总是对的。使用C-x C-b调出缓存区清单，它会同时显示每个缓存区名称和文件名称。 一些缓存区并不对应到文件。这种缓存区名称是”*Buffer List*“，你使用C-x C-b调出来的缓存区清单就没有对应到任何文件。本教程”TUTORIAL”缓存区最初也不是一个文件，单现在是，因为在之前的章节你使用C-x C-s把它保存到了一个文件中。 名称为”*Messages*“的缓存区也没有对应到任何文件。这个缓存区包含了在Emacs会话时候将消息显示在底部行。12输入`C-x b *Message* &lt;Return&gt;`来查看消息的缓存区然后输入`C-x b TUTORIAL &lt;Return&gt;`来回到这个教程 如果在一个文件中你修改了内容，然后找到另一个文件，那些内容不会保存在第一个文件中。那些修改留在了Emacs内部，在那个文件的缓存区中。创建和修改第二个文件的缓存区时并不会影响第一个文件的缓存区。这一点非常好用，但也意味着你需要一个方便的方法第一个文件缓存区。跳转回第一个文件缓存区，再使用C-x C-s保存，这样很麻烦。所以我们可以这样：C-x s保存一些缓存区 C-x s会询问你关于那些被修改了却没有保存的缓存区。它会询问那些缓存区，是否去保存。 扩展命令集（extending the command set）除了Control和Meta字符组合命令外，还有有非常非常多的Emacs命令。Emacs使用X命令来处理它们。有两种： C-x字符扩展。后面跟单个字符 M-x命令扩展。后面跟很长的名字 这些命令都比较有用，但相对于上面已经学到的命令来说使用地少。你已经见到过一些：文件命令C-x C-f和C-x C-s。再举个例子，终止Emacs会话的命令C-x C-c。（不必担心丢失修改；C-x C-c命令在关闭Emacs前提出保存每个被修改的文件） 如果使用图形化界面，不需要任何特殊命令就可以移动到另一个程序中。可以使用鼠标或者窗口管理命令。可是，如果使用文字终端，同一时间只能显示一个程序，你需要暂停Emacs去移动到其他程序。 C-z命令可以临时退出Emacs，以便于随后可以回到相同的Emacs会话。当使用Emacs的文字终端，使用C-z暂停Emacs；这样，可以不关闭Emacs而回到shell中。在多数通用的shell中，可以使用fg或者%emacs恢复Emacs。 有时使用C-x C-c来退出Emacs。使用它来退出为快速编辑而调用的Emacs也是正确的，例如通过邮件处理实用程序。 有非常多的C-x命令，这里罗列出之前学习到的一些： C-x C-fFind文件 C-x C-s保存文件 C-x s保存某些缓存区 C-x C-b列出所有缓存区 C-x b选择缓存区 C-x C-c退出Emacs C-x 1删除其他窗口只留一个 C-x u撤回 命名扩展命令通常情况下使用地更少，有些仅在某些模式下才会使用。例如替换字符串的命令，在缓存区中用一个字符串替换另一个。输入M-x，Emacs会在底部屏幕提示你输入命令名称。只需要输入repl s&lt;TAB&gt;Emacs将会补全名称，使用&lt;Return&gt;来提交命令。 替换字符串命令需要两个参数：被替换的字符串和替换它的字符串。必须使用&lt;Return&gt;来结束每个参数。M-x repl s&lt;Return&gt;changed&lt;Return&gt;altered&lt;Return&gt; ‘chagned’将会被替换为’altered’ 自动保存（auto save）在对文件作出修改时，但并没有进行保存，如果电脑发生故障，那些修改将会丢失。在这种情况下，为了保护你，Emacs会定期为每个修改过的文件写入到自动保存的文件中。自动保存的文件名是以’#’为开始和结束。举个例子，如果你的文件名是”hello.c”，那么自动保存的文件名就是”#hello.c#”。当你用正常的方式保存文件，Emacs会删除它的自动保存文件。 如果电脑崩溃，你可以用正常的查找文件来恢复自动保存的编辑，然后输入M-x recover-this-file &lt;Return&gt;。这是会要求确认，输入&lt;Return&gt;来恢复自动保存的数据。 回显区（echo area）如果Emacs看到你缓慢地输入多字符命令，会在屏幕底部显示给你，这个区域叫做”echo area”。这个回显区包括屏幕底部行。 模式行（mode line）紧靠回显区上方的行被称为”模式行”。模式行是一些类似于：1-:**- TUTORIAL 63% L749 (Fundamentale) 这行提供了一些有用的信息，有关与Emacs状态和正在编辑的内容。 你已经知道了文件名的含义–用这个名字可以查找到文件。NN%标志出当前在缓存文件内容的位置，它意味着缓存区的百分比时超过屏幕顶端。若缓存区的顶端在屏幕上，它将说明”Top”来替换”0%”。若缓存区的底端在屏幕上，它将显示”Bot”。如果看到缓存区较小，全部内容适合屏幕，那将显示”All”。 L和数字用另一种方式指出了当前位置：将给出当前点的行数。 前面的星号意味着对内容作出了修改。你访问或保存文件后，模式行显示没有星号，只有破折号。 模式行里括号中的部分是告诉你当前在什么编辑模式下。默认的编辑模式是Fundamental，是当前正在使用的模式。它是一个主要模式（Major Mode）的例子。 Emacs有很多不同的主要模式。有些表示着编辑不同语言和内容类型，例如Lisp模式，文本模式，等等。在任何时候有且仅有一个主要模式是激活状态的，而它的名字在模式行中可以找到，现在是”Fundamental”模式。 每个主要模式会有一些命令的行为不太一样。举个例子，在程序中创建注释的命令，因为每个编程语言都有看起来像但却有不同概念的注释，每个主要模式后不同的插入注释。每个主要模式都是扩展命令的名称，可以用它切换到不同的模式。例如，M-x fundamental-mode命令就可以切换到Fundamental模式。 如果要去编辑人类语言的内容，就像这个文件，你也许应使用Text模式。M-x text-mode &lt;Return&gt; 别担心，你学到的任何Emacs命令都不会有大的变化。但你会发现M-f和M-b把撇号当作单词的一部分。之前，在Funamental模式，M-f和M-b会把撇号当作单词分割符。 主要模式通常都有一点点的变化，就像这个：在主要模式中多数命令的功能都是一样的，但它们还是有一些微小的不同。 在当前主要模式下浏览这个文档，输入C-h m 主要模式之所以称之为主要，是因为还有次要模式（Minor Mode）。次要模式是不能替代主要模式的，只是他们的修饰。每个次要模式都可以打开或者关闭，独立于其他的次要模式，也独立于你的主要模式。你可以使用没有次要模式，或者一个、或多个组合的次要模式。 有个很有用的次要模式，特别是对于人类语言模式，他就是自动填充模式。若这个模式被启用，当你插入内容或者使行太宽时Emacs会自动地在单词间断行。有一点，自动填充模式仅依据空格来断行。 你可以使用M-x auto-fill-mode &lt;Return&gt;打开自动填充模式。在启用状态下，可以再次输入M-x auto-fill-mode &lt;Return&gt;来关闭。如果模式是启用的，这个命令可以关闭，如果模式是关闭的，这个命令可以启用它，我们称这种命令是”开关模式”（Toggles the mode）。 边距通常是设置为70个字符，但可以使用C-x f命令来改变它。可以将边距设置为你想要的任何数字。1&gt;&gt; 输入 C-x f 数字。（或者C-u 20 C-x f） 如果在段落中改变边距，自动填充模式并不会重新填充。可以使用M-q命令来重新填充当前光标所在的段落。 搜索（searching）Emacs支持搜索字符串，无论向前还是向后搜索。搜索字符串是一个光标移动命令，它会移动光标到下个匹配到的字符串出现的位置。 Emacs搜索命令是”增量的”。意思是当输入字符串时就会开始搜索。 C-s命令是向前搜索，C-r是向后搜索。当输入C-s后会有”I-search”立刻出现在回显区。这是告诉你Emacs现在处于增量的搜索模式，等待你输入想要搜索的字符串。&lt;Return&gt;来结束搜索。1234&gt;&gt; 输入C-s来开始搜索。缓慢地，一次一个字符地输入单词&quot;Cursor&quot;，期间可以观察到匹配到的字符都会高亮显示。这样就完成一次搜索&gt;&gt; 再次输入C-s，就会搜索下个匹配到的字符串&gt;&gt; 输入&lt;DEL&gt;，会找上一个匹配到的字符串，直到第一个搜到的字符串，这时会回到回显区编辑搜索的字符串&gt;&gt; 输入&lt;Return&gt;结束搜索 多窗口（multiple windows）Emacs有个很棒的功能是有时可以在一个屏幕显示多个窗口。（需要知道的是，Emacs使用的是”frames”这个术语，后面的章节都会使用这个术语，有些程序称之为”windows”。Emacs手册中包含了术语表）12345&gt;&gt; 移动光标到这行，然后输入C-l C-l&gt;&gt; 输入C-x 2，将会把屏幕分割为两个窗口。两个窗口都显示Tutorial。当前编辑的窗口扔会留在上方。&gt;&gt; 输入C-M-v（Control-Meta-v），滚动下方窗口&gt;&gt; 输入C-x o（&quot;o&quot;表示的是&quot;other&quot;），移动光标到下面的窗口，&gt;&gt; 再次输入C-x o，移动光标回到上面的窗口 可以使用C-x o在窗口之间切换。选择的窗口，也就是正在编辑的位置，会有一个闪烁的光标来突出显示。其他窗口也有他们的光标位置。如果在图形界面，光标可能是一个不闪烁的空心方框。 当你在编辑一个窗口且还需要参考其他窗口内容时，C-M-v命令会很好用。不用离开当前的窗口，你可以使用C-M-v来滚动另一个窗口。 C-M-v命令是CONTROL-META的一个典型例子。同时按住Control间和Meta键，再按输入其他的，Control和Meta按下的顺序无所谓。 如果键盘没有Meta，可以用&lt;ESC&gt;来代替。但你必须输入&lt;ESC&gt;之后再按Control-v，而Control-&lt;ESC&gt;-v是无效的。因为&lt;ESC&gt;是一个拥有功能的字符，而不是一个修饰键。 不会在两个窗口中显示同一个缓存区。如果你在一个窗口中使用C-x C-f打开一个文件，而另一个窗口不会发生改变。你可以在每个窗口独立地发现一个文件。 下面是另一种方式，在两个窗口显示不同的东西：12&gt;&gt; 输入C-x 4 C-f 文件名 &lt;Return&gt;，可以看到指定的文件出现在下方窗口，光标也在那里。&gt;&gt; 输入C-x o，回到上方窗口，使用C-x 1，关掉下方窗口 多画面（multiple frames）Emacs也可以创建多个画面。一个画面是窗口的集合，他们有统一的菜单、滚动条、回显区等等。在图形化界面，Emacs的画面也就是大多是程序的窗口。多个图形化画面可以被同时显示，而文本终端同一时间只能显示一个画面。12&gt;&gt; 输入C-x 5 2，会有新的画面显示在屏幕&gt;&gt; 输入C-x 5 0，会关闭选中的画面 在图形化界面可以使用普通的方式关闭画面（通常点击”X”按钮）。如果关闭最后一个画面，将会退出Emacs。 递归编辑层（recursive editing levels）有时你会进入到”递归编辑级层”。这表示在模式行中的方框，周围括号会把主要模式名称扩起来。例如，你也许会看到[(Fundamental)]而不是(Fundamental)。1&gt;&gt; 输入M-x，进入到迷你缓存区；然后输入&lt;ESC&gt;&lt;ESC&gt;&lt;ESC&gt;退出 此时不能使用C-g来退出递归编辑层。因为C-g被使用在取消命令和参数上。 获得更多帮助（getting more help）本教程试图为入门Emacs提供足够多的信息。但还有更多有用的信息无法完全在这里解释。但是，你应学习更多关于Emacs的内容，因为他们都是很有用的特性。Emacs提供命令去读取与命令有关的文档。这些帮助命令都是以C-h开始。 去使用帮助功能，输入C-h，然后输入想要寻求帮助的字符。如果你有不清楚的，不妨输入C-h？Emacs将会为你提供帮助。如果你输入了C-h之后却不再需要任何帮助，那么输入C-g退出。（如果C-h在屏幕底部没有显示任何帮助信息，尝试使用F1或者M-x help &lt;Return&gt;） C-h c可以提供基本的帮助，例如C-h c C-p，输入C-h，再输入c，再输入需要帮助的命令。Emacs将会显示一条简短的帮助信息。 C-h k可以提供更多的帮助信息，例如C-h k C-p。它将在一个新的窗口显示功能文档。当阅读完成后，使用C-x 1回到当前编辑窗口。 C-h f输入函数名称，来查看对应的帮助文档，例如：C-h f previous-line &lt;Return&gt; C-h v输入变量名称，可以显示变量的文档。 C-h a输入关键字，可以列出所有包含关键字的命令。例如：C-h a file &lt;Return&gt; C-h i阅读内部手册。它会带你到一个名为”*info*“的缓存区阅读本系统中安装的package的手册。输入m emacs &lt;Return&gt;来读取Emacs手册，如果之前没有使用过这些，输入h将会带你到指引册。如果你曾通过本教程，你将查阅Emacs信息手册作为你主要的文档。 更多功能（more features）你可以阅读手册来学到Emacs的更多知识。两个功能你也许会特别喜欢，一个是Completion，保存输入。另一个是Dired，简单的文件控制。 Completion是避开不必要输入的一种方式。比如，如果你想要跳转到*Message*缓存区，你可以输入C-x b *M&lt;Tab&gt;，Emacs将根据你已输入的内容确定其余的缓冲区名称。 Dired让你在目录中列出文件，移动，列出，访问，重命名，删除和其他文件操作。 结尾（conclusion）使用C-x C-c来退出Emacs。 这个教程是对所有新手来说都是可理解的，如果你发现一些不清楚的地方，不要坐下来责备自己-抱怨。 版权（copying）GNU Emacs]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>emacs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一键连接VPN (Cisco AnyConnect Client)]]></title>
    <url>%2F2018%2F07%2F23%2Fonekey_vpn%2F</url>
    <content type="text"><![CDATA[公司VPN使用了Cisco Anyconnect客户端，并且有用户名密码+动态验证码双重认证，每次连接都需要繁琐的输入用户名密码，打开手机查看动态验证码，再输入到客户端。懒惰就是生产力，所以，我们要想办法偷懒。 1. 配置前准备 Cisco Client Username:Password Google Authenticator 2. 生成动态验证码安装oath-toolkit使用brew直接安装， 1brew install oath-toolkit 记录动态验证码的Token将Google Authenticator绑定的二维码扫描出来，拿到一段Token，保存到文件~/.optkeys 1google=UKPPIDEALLKPYTT9 创建脚本生成动态验证码新建文件~/oath.sh 123456789101112131415161718192021222324#!/bin/bash#fork from http://superuser.com/questions/462478/is-there-a-google-authenticator-desktop-client , by Peter Beckmanscriptname=`basename $0`if [ -z $1 ]thenecho "$scriptname: Service Name Req'd"echo ""echo "Usage:"echo " otp google"echo ""echo "Configuration: $HOME/.otpkeys"echo "Format: name=key"exitfiotpkey=` grep ^$1 $HOME/.otpkeys | cut -d"=" -f 2 | sed "s/ //g" `if [ -z $otpkey ]thenecho "$scriptname: Bad Service Name"exitfitoken=`/usr/local/bin/oathtool --totp -b $otpkey`echo $tokenecho $token | /usr/bin/pbcopy 使用oath.sh生成验证码 12sh ~/oath.sh google123456 3. 配置连接VPN编写VPN连接脚本~/vpn.sh1234567891011121314151617181920212223242526272829#!/bin/bashif [ $# -eq 1 ]then command=$1else command='connect'fiif [ $command == 'stop' ]then echo 'stop vpn' /opt/cisco/anyconnect/bin/vpn disconnect exitfiecho 'start vpn'username=用户名passwd=密码authtype=认证类型authcode=`sh ./oath.sh google`/opt/cisco/anyconnect/bin/vpn -s &lt;&lt; EOFconnect VPN地址$username$passwd$authtype$authcodeEOF 将内容替换为自己的配置 1234用户名，VPN连接的用户名密码认证类型，我司的Google Authenticator是4VPN地址，我司的是vpn.xxx.com 连接VPN1./vpn.sh start 关闭VPN1./vpn.sh stop 还要更简单，可以在profile中配置alias，比如在.zshrc中加入 123# # aliases for vpnalias von="sh ~/vpn.sh start"alias voff="sh ~/vpn.sh stop" 现在即可使用von和voff快速开关VPN了。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>vpn</tag>
        <tag>cisco</tag>
        <tag>anyconnect</tag>
      </tags>
  </entry>
</search>
